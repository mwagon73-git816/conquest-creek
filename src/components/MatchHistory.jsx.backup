import React, { useState, useEffect } from 'react';
import { TrendingUp, Edit, Trash2, ChevronDown, ChevronUp, Filter, Clock, Calendar, Check, Edit2, X, AlertCircle } from 'lucide-react';
import { formatNTRP, formatDate } from '../utils/formatters';
import { ACTION_TYPES, createLogEntry } from '../services/activityLogger';
import { generateMatchId } from '../utils/idGenerator';
import { tournamentStorage } from '../services/storage';
import { subscribeToMatches, updateMatch, deleteMatch as deleteMatchDoc } from '../services/matchService';
import TeamLogo from './TeamLogo';
import MatchResultsModal from './MatchResultsModal';
import {
  MATCH_TYPES,
  validatePlayerSelection as validatePlayerCount,
  calculateCombinedNTRP as calcCombinedNTRP,
  validateCombinedNTRP as validateNTRPLimit,
  getRequiredPlayerCount,
  getPlayerSelectionLabel,
  getPlayerLimitAlert,
  getPlayerSelectionError,
  formatMatchType,
  getMatchType,
  getDisplayMatchType,
  getEffectiveMatchType
} from '../utils/matchUtils';

const MatchHistory = ({ matches, setMatches, teams, isAuthenticated, setActiveTab, players, userRole, userTeamId, setEditingMatch, challenges, onEnterPendingResults, onChallengesChange, addLog }) => {
  const [allMatches, setAllMatches] = useState([]);
  const [showFilters, setShowFilters] = useState(false);

  // Subscribe to matches from Firestore
  useEffect(() => {
    console.log('ðŸ“Š MatchHistory: Subscribing to matches...');
    const unsubscribe = subscribeToMatches(
      (updatedMatches) => {
        console.log(`ðŸ“Š MatchHistory: Received ${updatedMatches.length} matches from Firestore`);
        setAllMatches(updatedMatches);
      },
      (error) => {
        console.error('âŒ MatchHistory: Failed to load matches:', error);
      }
    );

    return () => {
      console.log('ðŸ“Š MatchHistory: Unsubscribing from matches');
      unsubscribe();
    };
  }, []);
  const [selectedTeams, setSelectedTeams] = useState([]);
  const [selectedPlayers, setSelectedPlayers] = useState([]);
  const [matchStatusFilter, setMatchStatusFilter] = useState('all'); // 'all', 'pending', 'completed'
  const [matchTypeFilter, setMatchTypeFilter] = useState('all'); // 'all', 'singles', 'doubles'
  const [sortOrder, setSortOrder] = useState('newest'); // 'newest' or 'oldest'

  // Collapsible sections state
  const [pendingExpanded, setPendingExpanded] = useState(false); // Default: collapsed
  const [completedExpanded, setCompletedExpanded] = useState(false); // Default: collapsed

  // Edit pending match states
  const [showEditPendingModal, setShowEditPendingModal] = useState(false);
  const [editingPendingMatch, setEditingPendingMatch] = useState(null);
  const [editPendingFormData, setEditPendingFormData] = useState({
    acceptedDate: '',
    acceptedLevel: '7.0',
    team1Players: [],
    team2Players: []
  });

  // Enter Results Modal states (simplified for shared modal)
  const [showResultsModal, setShowResultsModal] = useState(false);
  const [selectedMatch, setSelectedMatch] = useState(null);

  const handleEditMatch = (match) => {
    // Pass the match data to MatchEntry for editing
    setEditingMatch(match);
    setActiveTab('entry');
  };

  const handleDeleteMatch = (matchId) => {
    if (confirm('Delete this match?')) {
      setMatches(matches.filter(m => m.id !== matchId));
    }
  };

  const getPlayerName = (playerId) => {
    const player = players.find(p => p.id === playerId);
    if (!player) return 'Unknown Player';
    return `${player.firstName} ${player.lastName}`;
  };

  const formatSetScores = (match) => {
    const setScores = [];

    // Determine if team1 or team2 won
    const isTeam1Winner = match.winner === 'team1';

    // Add Set 1 - show winner's score first
    if (match.set1Team1 !== undefined && match.set1Team2 !== undefined) {
      const set1Score = isTeam1Winner
        ? `${match.set1Team1}-${match.set1Team2}`
        : `${match.set1Team2}-${match.set1Team1}`;
      setScores.push(set1Score);
    }

    // Add Set 2 - show winner's score first
    if (match.set2Team1 !== undefined && match.set2Team2 !== undefined) {
      const set2Score = isTeam1Winner
        ? `${match.set2Team1}-${match.set2Team2}`
        : `${match.set2Team2}-${match.set2Team1}`;
      setScores.push(set2Score);
    }

    // Add Set 3 - show winner's score first, with tiebreaker notation if applicable
    if (match.set3Team1 !== undefined && match.set3Team2 !== undefined &&
        (match.set3Team1 !== '' || match.set3Team2 !== '')) {
      const set3Score = isTeam1Winner
        ? `${match.set3Team1}-${match.set3Team2}`
        : `${match.set3Team2}-${match.set3Team1}`;
      const tbNotation = match.set3IsTiebreaker ? ' TB' : '';
      setScores.push(set3Score + tbNotation);
    }

    // If no individual set scores available, fall back to old format
    if (setScores.length === 0) {
      return `${match.team1Sets}-${match.team2Sets} sets â€¢ ${match.team1Games}-${match.team2Games} games`;
    }

    return `(${setScores.join(', ')})`;
  };

  const handleTeamToggle = (teamId) => {
    if (selectedTeams.includes(teamId)) {
      setSelectedTeams(selectedTeams.filter(id => id !== teamId));
    } else {
      setSelectedTeams([...selectedTeams, teamId]);
    }
  };

  const handlePlayerToggle = (playerId) => {
    if (selectedPlayers.includes(playerId)) {
      setSelectedPlayers(selectedPlayers.filter(id => id !== playerId));
    } else {
      setSelectedPlayers([...selectedPlayers, playerId]);
    }
  };

  const handleClearFilters = () => {
    setSelectedTeams([]);
    setSelectedPlayers([]);
  };

  const hasActiveFilters = selectedTeams.length > 0 || selectedPlayers.length > 0;

  // Get pending matches from Firestore (no longer derived from challenges)
  const getPendingMatches = () => {
    const pending = allMatches
      .filter(m => m.status === 'pending')
      .sort((a, b) => {
        // Sort by scheduled date, respecting sortOrder toggle
        const dateA = new Date(a.scheduledDate || a.createdAt);
        const dateB = new Date(b.scheduledDate || b.createdAt);

        // Respect the sortOrder state
        return sortOrder === 'newest'
          ? dateB - dateA  // Newest first
          : dateA - dateB; // Oldest first
      });

    return pending;
  };

  // Get team name helper
  const getTeamName = (teamId) => {
    const team = teams.find(t => t.id === teamId);
    return team ? team.name : 'Unknown Team';
  };

  // Get player names from IDs
  const getPlayerNames = (playerIds) => {
    if (!playerIds || playerIds.length === 0) return [];
    return playerIds.map(id => {
      const player = players.find(p => p.id === id);
      return player ? {
        name: `${player.firstName} ${player.lastName}`,
        rating: player.ntrpRating,
        gender: player.gender
      } : null;
    }).filter(p => p !== null);
  };

  // Check if user can enter results for a pending match
  const canEnterResults = (pendingMatch) => {
    if (!isAuthenticated) return false;
    if (userRole === 'director') return true;
    if (userRole === 'captain' && userTeamId) {
      return pendingMatch.team1Id === userTeamId ||
             pendingMatch.team2Id === userTeamId;
    }
    return false;
  };

  // Check if user can edit a pending match
  const canEditPendingMatch = (pendingMatch) => {
    if (!isAuthenticated) return false;
    // Directors can edit any pending match
    if (userRole === 'director') return true;
    // Captains can edit pending matches their team is involved in
    if (userRole === 'captain' && userTeamId) {
      return pendingMatch.team1Id === userTeamId || pendingMatch.team2Id === userTeamId;
    }
    return false;
  };

  // Get team roster for player selection
  const getTeamRoster = (teamId) => {
    return players.filter(p => p.teamId === teamId && p.status === 'active');
  };

  // Calculate combined NTRP rating for selected players
  const calculateCombinedNTRP = (selectedPlayerIds, matchType = MATCH_TYPES.DOUBLES) => {
    return calcCombinedNTRP(selectedPlayerIds, players, matchType);
  };

  // Validation: correct number of players must be selected for match type
  const validatePlayerSelection = (selectedPlayers, matchType = MATCH_TYPES.DOUBLES) => {
    return validatePlayerCount(selectedPlayers, matchType);
  };

  // Validation: combined NTRP doesn't exceed match level
  const validateCombinedNTRP = (selectedPlayers, matchLevel, matchType = MATCH_TYPES.DOUBLES) => {
    return validateNTRPLimit(selectedPlayers, players, matchLevel, matchType);
  };

  // Handle edit pending match
  const handleEditPendingMatch = (pendingMatch) => {
    setEditingPendingMatch(pendingMatch);
    setEditPendingFormData({
      acceptedDate: pendingMatch.scheduledDate || '',
      acceptedLevel: pendingMatch.level || '7.0',
      team1Players: pendingMatch.team1Players || [],
      team2Players: pendingMatch.team2Players || []
    });
    setShowEditPendingModal(true);
  };

  // Handle deleting a pending match (directors only)
  const handleDeletePendingMatch = async (pendingMatch) => {
    if (userRole !== 'director') {
      alert('âš ï¸ Only tournament directors can delete pending matches.');
      return;
    }

    const team1 = teams.find(t => t.id === pendingMatch.team1Id);
    const team2 = teams.find(t => t.id === pendingMatch.team2Id);
    const team1Name = team1?.name || 'Unknown Team';
    const team2Name = team2?.name || 'Unknown Team';
    const matchDescription = `${team1Name} vs ${team2Name} (Level ${pendingMatch.level})`;

    if (!confirm(`Are you sure you want to delete this pending match?\n\n${matchDescription}\n\nThis action cannot be undone.`)) {
      return;
    }

    try {
      // Delete the match from Firestore
      await deleteMatchDoc(pendingMatch.matchId);

      // Log the deletion
      addLog(
        ACTION_TYPES.PENDING_MATCH_DELETED,
        {
          matchDescription,
          team1Name,
          team2Name,
          team1Id: pendingMatch.team1Id,
          team2Id: pendingMatch.team2Id,
          level: pendingMatch.level,
          scheduledDate: pendingMatch.scheduledDate
        },
        pendingMatch.matchId,
        pendingMatch,
        null
      );

      alert('âœ… Pending match deleted successfully.');
    } catch (error) {
      console.error('âŒ Failed to delete pending match:', error);
      alert('âŒ Failed to delete pending match. Please try again.');
    }
  };

  const handleConfirmEditPending = async () => {
    // Validation
    if (!editPendingFormData.acceptedDate) {
      alert('âš ï¸ Please select a match date.');
      return;
    }

    if (!validatePlayerSelection(editPendingFormData.team1Players)) {
      alert('âš ï¸ Please select exactly 2 players for Team 1.');
      return;
    }

    if (!validatePlayerSelection(editPendingFormData.team2Players)) {
      alert('âš ï¸ Please select exactly 2 players for Team 2.');
      return;
    }

    if (!validateCombinedNTRP(editPendingFormData.team1Players, editPendingFormData.acceptedLevel)) {
      const combinedRating = calculateCombinedNTRP(editPendingFormData.team1Players);
      alert(`Team 1 combined NTRP rating (${combinedRating.toFixed(1)}) exceeds match level (${editPendingFormData.acceptedLevel}).`);
      return;
    }

    if (!validateCombinedNTRP(editPendingFormData.team2Players, editPendingFormData.acceptedLevel)) {
      const combinedRating = calculateCombinedNTRP(editPendingFormData.team2Players);
      alert(`Team 2 combined NTRP rating (${combinedRating.toFixed(1)}) exceeds match level (${editPendingFormData.acceptedLevel}).`);
      return;
    }

    try {
      // Track what changed for activity log
      const changes = [];
      if (editPendingFormData.acceptedDate !== editingPendingMatch.scheduledDate) {
        changes.push('date');
      }
      if (editPendingFormData.acceptedLevel !== editingPendingMatch.level) {
        changes.push('level');
      }
      if (JSON.stringify(editPendingFormData.team1Players.sort()) !== JSON.stringify((editingPendingMatch.team1Players || []).sort())) {
        changes.push('team1 players');
      }
      if (JSON.stringify(editPendingFormData.team2Players.sort()) !== JSON.stringify((editingPendingMatch.team2Players || []).sort())) {
        changes.push('team2 players');
      }

      // Update pending match in Firestore
      const updateData = {
        scheduledDate: editPendingFormData.acceptedDate,
        level: editPendingFormData.acceptedLevel,
        team1Players: editPendingFormData.team1Players,
        team2Players: editPendingFormData.team2Players,
        team1CombinedNTRP: calculateCombinedNTRP(editPendingFormData.team1Players),
        team2CombinedNTRP: calculateCombinedNTRP(editPendingFormData.team2Players),
        lastEditedBy: userRole === 'director' ? 'Tournament Director' : 'Captain',
        lastEditedAt: new Date().toISOString()
      };

      await updateMatch(editingPendingMatch.matchId, updateData, updateData.lastEditedBy);

      // Log the edit activity
      if (addLog && changes.length > 0) {
        const team1Name = getTeamName(editingPendingMatch.team1Id);
        const team2Name = getTeamName(editingPendingMatch.team2Id);
        addLog(
          ACTION_TYPES.PENDING_MATCH_EDITED,
          {
            team1Name,
            team2Name,
            changesSummary: `Updated ${changes.join(', ')}`
          },
          editingPendingMatch.matchId,
          editingPendingMatch,
          { ...editingPendingMatch, ...updateData }
        );
      }

      // Reset form
      setShowEditPendingModal(false);
      setEditingPendingMatch(null);
      setEditPendingFormData({
        acceptedDate: '',
        acceptedLevel: '7.0',
        team1Players: [],
        team2Players: []
      });

      alert('âœ… Pending match updated successfully!');
    } catch (error) {
      console.error('âŒ Failed to update pending match:', error);
      alert('âŒ Failed to update pending match. Please try again.');
    }
  };

  // ===== ENTER RESULTS MODAL FUNCTIONS (Simplified for shared modal) =====

  // Open results entry modal
  const handleOpenResultsModal = (match) => {
    setSelectedMatch(match);
    setShowResultsModal(true);
  };

  // Close results modal
  const handleCloseResultsModal = () => {
    setShowResultsModal(false);
    setSelectedMatch(null);
  };

  // Handle match result submission from shared modal
  const handleSubmitResults = async (matchResult) => {
    if (!selectedMatch) return;

    try {
      // Update the pending match to completed with results
      const updateData = {
        status: 'completed',
        date: matchResult.date,
        winner: matchResult.winner,
        set1Team1: matchResult.set1Team1,
        set1Team2: matchResult.set1Team2,
        set2Team1: matchResult.set2Team1,
        set2Team2: matchResult.set2Team2,
        set3Team1: matchResult.set3Team1 || '',
        set3Team2: matchResult.set3Team2 || '',
        set3IsTiebreaker: matchResult.set3IsTiebreaker || false,
        team1Sets: matchResult.team1Sets,
        team2Sets: matchResult.team2Sets,
        team1Games: matchResult.team1Games,
        team2Games: matchResult.team2Games,
        notes: matchResult.notes || '',
        completedAt: new Date().toISOString(),
        completedBy: userRole === 'director' ? 'Tournament Director' : 'Captain'
      };

      await updateMatch(selectedMatch.matchId, updateData, updateData.completedBy);

      // Close the modal
      handleCloseResultsModal();

      alert('âœ… Match results recorded successfully!');
    } catch (error) {
      console.error('âŒ Failed to record match results:', error);
      alert('âŒ Failed to record match results. Please try again.');
    }
  };

  // Sort matches by scheduled date (if available), then completion date, then by timestamp
  const sortedMatches = [...matches].sort((a, b) => {
    // Prioritize scheduled date (from challenges), fallback to completion date
    const dateA = new Date(a.scheduledDate || a.date);
    const dateB = new Date(b.scheduledDate || b.date);

    // If dates are different, sort by date
    if (dateA.getTime() !== dateB.getTime()) {
      return sortOrder === 'newest'
        ? dateB.getTime() - dateA.getTime() // Newest first
        : dateA.getTime() - dateB.getTime(); // Oldest first
    }

    // If dates are the same, sort by timestamp if available
    if (a.timestamp && b.timestamp) {
      return sortOrder === 'newest'
        ? new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
        : new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
    }

    return 0;
  });

  // Apply filters
  const filteredMatches = sortedMatches.filter(match => {
    // Captain restriction: only show matches involving their team
    if (userRole === 'captain' && userTeamId) {
      const captainTeamInvolved = match.team1Id === userTeamId || match.team2Id === userTeamId;
      if (!captainTeamInvolved) return false;
    }

    // Team filter
    if (selectedTeams.length > 0) {
      const matchHasSelectedTeam = selectedTeams.includes(match.team1Id) ||
                                   selectedTeams.includes(match.team2Id);
      if (!matchHasSelectedTeam) return false;
    }

    // Player filter
    if (selectedPlayers.length > 0) {
      const matchPlayers = [
        ...(match.team1Players || []),
        ...(match.team2Players || [])
      ];
      const matchHasSelectedPlayer = selectedPlayers.some(playerId =>
        matchPlayers.includes(playerId)
      );
      if (!matchHasSelectedPlayer) return false;
    }

    // Match type filter (using hybrid detection for Mixed Doubles)
    if (matchTypeFilter !== 'all') {
      const currentMatchType = getEffectiveMatchType(match, players);
      if (currentMatchType !== matchTypeFilter) return false;
    }

    return true;
  });

  // Debug: Log match counts by status
  console.log('\nðŸ” MATCH FILTERING DEBUG:');
  console.log(`Total matches (sortedMatches): ${sortedMatches.length}`);
  console.log(`After filters (filteredMatches): ${filteredMatches.length}`);
  const pendingInFiltered = filteredMatches.filter(m => m.status === 'pending');
  const completedInFiltered = filteredMatches.filter(m => m.status === 'completed');
  console.log(`  - Pending in filteredMatches: ${pendingInFiltered.length}`);
  console.log(`  - Completed in filteredMatches: ${completedInFiltered.length}`);
  if (pendingInFiltered.length > 0) {
    console.log('âš ï¸ WARNING: filteredMatches contains pending matches! These should be filtered separately.');
    console.log('Pending matches:', pendingInFiltered.map(m => ({ id: m.matchId, status: m.status, scheduled: m.scheduledDate })));
  }

  // Get and filter pending matches
  const allPendingMatches = getPendingMatches();

  const filteredPendingMatches = allPendingMatches.filter(match => {
    // Captain restriction: only show matches involving their team
    if (userRole === 'captain' && userTeamId) {
      const captainTeamInvolved = match.team1Id === userTeamId ||
                                   match.team2Id === userTeamId;
      if (!captainTeamInvolved) return false;
    }

    // Team filter
    if (selectedTeams.length > 0) {
      const matchHasSelectedTeam = selectedTeams.includes(match.team1Id) ||
                                   selectedTeams.includes(match.team2Id);
      if (!matchHasSelectedTeam) return false;
    }

    // Player filter
    if (selectedPlayers.length > 0) {
      const matchPlayers = [
        ...(match.team1Players || []),
        ...(match.team2Players || [])
      ];
      const matchHasSelectedPlayer = selectedPlayers.some(playerId =>
        matchPlayers.includes(playerId)
      );
      if (!matchHasSelectedPlayer) return false;
    }

    // Match type filter (using hybrid detection for Mixed Doubles)
    if (matchTypeFilter !== 'all') {
      const currentMatchType = getEffectiveMatchType(match, players);
      if (currentMatchType !== matchTypeFilter) return false;
    }

    return true;
  });

  const totalMatches = matches.length;
  const totalPending = allPendingMatches.length;
  const displayedMatches = filteredMatches.length;
  const displayedPending = filteredPendingMatches.length;

  // ===== TODAY'S MATCHES FILTERING LOGIC =====
  // Get today's date in YYYY-MM-DD format (local timezone)
  const today = new Date();
  const todayString = today.toLocaleDateString('en-CA'); // 'en-CA' gives YYYY-MM-DD format

  // Debugging logs
  console.log('ðŸ—“ï¸ TODAY\'S MATCHES DEBUG');
  console.log('Current date/time:', today.toString());
  console.log('Today in local timezone (YYYY-MM-DD):', todayString);
  console.log('User timezone:', Intl.DateTimeFormat().resolvedOptions().timeZone);
  console.log('Timezone offset (minutes):', today.getTimezoneOffset());

  // Helper function to check if a date matches today (timezone-safe)
  const isToday = (dateValue) => {
    if (!dateValue) return false;

    let dateString;

    // Handle different date formats
    if (typeof dateValue === 'string') {
      // If it's a string like "2025-11-25" or "2025-11-25T00:00:00"
      dateString = dateValue.split('T')[0]; // Get just the YYYY-MM-DD part
    } else if (dateValue.toDate && typeof dateValue.toDate === 'function') {
      // If it's a Firestore Timestamp
      dateString = dateValue.toDate().toLocaleDateString('en-CA');
    } else if (dateValue instanceof Date) {
      // If it's already a Date object
      dateString = dateValue.toLocaleDateString('en-CA');
    } else {
      // Try to parse it as a Date
      try {
        const parsed = new Date(dateValue);
        if (!isNaN(parsed.getTime())) {
          dateString = parsed.toLocaleDateString('en-CA');
        } else {
          return false;
        }
      } catch (e) {
        console.error('Failed to parse date:', dateValue, e);
        return false;
      }
    }

    const matches = dateString === todayString;

    // Debug log for each comparison
    if (matches) {
      console.log('âœ… Match found for today:', { dateValue, dateString, todayString });
    }

    return matches;
  };

  // Debug: Log all pending matches with their dates
  console.log('\nðŸ“‹ PENDING MATCHES DATE CHECK:');
  filteredPendingMatches.forEach((match, idx) => {
    const team1Name = getTeamName(match.team1Id);
    const team2Name = getTeamName(match.team2Id);
    const dateStr = match.scheduledDate;
    const isTodayMatch = isToday(dateStr);

    console.log(`${idx + 1}. ${team1Name} vs ${team2Name}`);
    console.log(`   Scheduled: ${dateStr}`);
    console.log(`   Is Today: ${isTodayMatch ? 'âœ… YES' : 'âŒ NO'}`);
  });

  // Debug: Log all completed matches with their dates
  console.log('\nðŸ“‹ COMPLETED MATCHES DATE CHECK:');
  filteredMatches.slice(0, 10).forEach((match, idx) => {
    const team1 = teams.find(t => t.id == match.team1Id);
    const team2 = teams.find(t => t.id == match.team2Id);
    const team1Name = team1?.name || 'Unknown';
    const team2Name = team2?.name || 'Unknown';
    const scheduledDate = match.scheduledDate;
    const completedDate = match.date;
    const isTodayMatch = isToday(scheduledDate) || isToday(completedDate);

    console.log(`${idx + 1}. ${team1Name} vs ${team2Name}`);
    console.log(`   Scheduled: ${scheduledDate || 'N/A'}`);
    console.log(`   Completed: ${completedDate || 'N/A'}`);
    console.log(`   Is Today: ${isTodayMatch ? 'âœ… YES' : 'âŒ NO'}`);
  });

  // Filter today's pending matches
  const todaysPendingMatches = filteredPendingMatches.filter(match =>
    isToday(match.scheduledDate)
  );

  // Filter today's completed matches (MUST check status='completed')
  const todaysCompletedMatches = filteredMatches.filter(match =>
    match.status === 'completed' &&
    (isToday(match.scheduledDate) || isToday(match.date))
  );

  // All today's matches combined (pending + completed)
  const todaysMatches = [...todaysPendingMatches, ...todaysCompletedMatches];

  // Pending matches excluding today
  const pendingMatchesExcludingToday = filteredPendingMatches.filter(match =>
    !isToday(match.scheduledDate)
  );

  // Completed matches excluding today (MUST check status='completed')
  const completedMatchesExcludingToday = filteredMatches.filter(match =>
    match.status === 'completed' &&
    !isToday(match.scheduledDate) && !isToday(match.date)
  );

  // Debug: Verify completed matches have correct status
  console.log('\nðŸ” COMPLETED MATCHES VERIFICATION:');
  console.log(`Today's completed matches: ${todaysCompletedMatches.length}`);
  if (todaysCompletedMatches.length > 0) {
    console.log('Sample today completed:', todaysCompletedMatches.slice(0, 3).map(m => ({
      id: m.matchId,
      status: m.status,
      scheduled: m.scheduledDate,
      score: `${m.team1Sets || '?'}-${m.team2Sets || '?'}`
    })));
  }
  console.log(`Completed matches (excluding today): ${completedMatchesExcludingToday.length}`);
  if (completedMatchesExcludingToday.length > 0) {
    console.log('Sample excluding today:', completedMatchesExcludingToday.slice(0, 3).map(m => ({
      id: m.matchId,
      status: m.status,
      scheduled: m.scheduledDate,
      score: `${m.team1Sets || '?'}-${m.team2Sets || '?'}`
    })));
  }

  // Check for any pending matches that might have leaked through
  const leakedPending = [...todaysCompletedMatches, ...completedMatchesExcludingToday].filter(m => m.status !== 'completed');
  if (leakedPending.length > 0) {
    console.error('âŒ ERROR: Pending matches leaked into completed section!');
    console.error('Leaked matches:', leakedPending.map(m => ({ id: m.matchId, status: m.status })));
  } else {
    console.log('âœ… No pending matches leaked into completed sections');
  }

  // Final summary
  console.log('\nâœ… TODAY\'S MATCHES SUMMARY:');
  console.log(`Total today's matches: ${todaysMatches.length}`);
  console.log(`- Pending: ${todaysPendingMatches.length}`);
  console.log(`- Completed: ${todaysCompletedMatches.length}`);
  console.log(`Pending (excluding today): ${pendingMatchesExcludingToday.length}`);
  console.log(`Completed (excluding today): ${completedMatchesExcludingToday.length}`);
  console.log('â”€'.repeat(60));

  // Determine what to show based on status filter
  const showPending = matchStatusFilter === 'all' || matchStatusFilter === 'pending';
  const showCompleted = matchStatusFilter === 'all' || matchStatusFilter === 'completed';

  // Check if user can edit/delete a match
  const canEditMatch = (match) => {
    if (userRole === 'director') return true;
    if (userRole === 'captain' && userTeamId) {
      // Captains can only edit matches involving their team
      return match.team1Id === userTeamId || match.team2Id === userTeamId;
    }
    return false;
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
        <TrendingUp className="w-6 h-6" />
        Matches
      </h2>

      {/* Status Filter, Match Type Filter, and Sort Order */}
      <div className="mb-4 grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label className="block text-sm font-medium mb-2">Filter by Status:</label>
          <select
            value={matchStatusFilter}
            onChange={(e) => setMatchStatusFilter(e.target.value)}
            className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="all">All Matches</option>
            <option value="pending">Pending Only</option>
            <option value="completed">Completed Only</option>
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Filter by Match Type:</label>
          <select
            value={matchTypeFilter}
            onChange={(e) => setMatchTypeFilter(e.target.value)}
            className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="all">All Types</option>
            <option value={MATCH_TYPES.SINGLES}>Singles</option>
            <option value={MATCH_TYPES.DOUBLES}>Doubles</option>
            <option value={MATCH_TYPES.MIXED_DOUBLES}>Mixed Doubles</option>
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Sort Order:</label>
          <select
            value={sortOrder}
            onChange={(e) => setSortOrder(e.target.value)}
            className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="newest">Newest First</option>
            <option value="oldest">Oldest First</option>
          </select>
        </div>
      </div>

      {/* Team/Player Filters Section */}
      <div className="mb-4">
        <button
          onClick={() => setShowFilters(!showFilters)}
          className="flex items-center gap-2 px-4 py-2 bg-blue-100 hover:bg-blue-200 text-blue-800 rounded-lg transition-colors"
        >
          <Filter className="w-4 h-4" />
          <span className="font-semibold">
            {showFilters ? 'Hide Filters' : 'Show Team/Player Filters'}
          </span>
          {hasActiveFilters && (
            <span className="bg-blue-600 text-white text-xs px-2 py-1 rounded-full">
              {selectedTeams.length + selectedPlayers.length}
            </span>
          )}
          {showFilters ? (
            <ChevronUp className="w-4 h-4" />
          ) : (
            <ChevronDown className="w-4 h-4" />
          )}
        </button>

        {showFilters && (
          <div className="mt-3 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Team Filter */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <label className="block text-sm font-semibold text-gray-700">
                    Filter by Team
                  </label>
                  {selectedTeams.length > 0 && (
                    <span className="text-xs text-blue-600 font-medium">
                      {selectedTeams.length} selected
                    </span>
                  )}
                </div>
                <div className="bg-white border border-blue-200 rounded p-3 max-h-48 overflow-y-auto">
                  {teams.length === 0 ? (
                    <p className="text-sm text-gray-500">No teams available</p>
                  ) : (
                    <div className="space-y-2">
                      {teams.map(team => (
                        <label
                          key={team.id}
                          className="flex items-center gap-2 cursor-pointer hover:bg-blue-50 p-1 rounded"
                        >
                          <input
                            type="checkbox"
                            checked={selectedTeams.includes(team.id)}
                            onChange={() => handleTeamToggle(team.id)}
                            className="w-4 h-4 text-blue-600"
                          />
                          <TeamLogo team={team} size="sm" showBorder={!!team.logo} />
                          <span className="text-sm">{team.name}</span>
                        </label>
                      ))}
                    </div>
                  )}
                </div>
              </div>

              {/* Player Filter */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <label className="block text-sm font-semibold text-gray-700">
                    Filter by Player
                  </label>
                  {selectedPlayers.length > 0 && (
                    <span className="text-xs text-blue-600 font-medium">
                      {selectedPlayers.length} selected
                    </span>
                  )}
                </div>
                <div className="bg-white border border-blue-200 rounded p-3 max-h-48 overflow-y-auto">
                  {!players || players.length === 0 ? (
                    <p className="text-sm text-gray-500">No players available</p>
                  ) : (
                    <div className="space-y-2">
                      {players
                        .filter(p => p.status === 'active')
                        .sort((a, b) => {
                          const nameA = `${a.lastName} ${a.firstName}`.toLowerCase();
                          const nameB = `${b.lastName} ${b.firstName}`.toLowerCase();
                          return nameA.localeCompare(nameB);
                        })
                        .map(player => (
                          <label
                            key={player.id}
                            className="flex items-center gap-2 cursor-pointer hover:bg-blue-50 p-1 rounded"
                          >
                            <input
                              type="checkbox"
                              checked={selectedPlayers.includes(player.id)}
                              onChange={() => handlePlayerToggle(player.id)}
                              className="w-4 h-4 text-blue-600"
                            />
                            <span className="text-sm">
                              {player.lastName}, {player.firstName}
                              <span className="text-xs text-gray-500 ml-1">
                                ({player.gender} {formatNTRP(player.ntrpRating)})
                              </span>
                            </span>
                          </label>
                        ))}
                    </div>
                  )}
                </div>
              </div>
            </div>

            {/* Clear Filters Button */}
            {hasActiveFilters && (
              <div className="mt-4 flex justify-end">
                <button
                  onClick={handleClearFilters}
                  className="px-4 py-2 bg-red-100 hover:bg-red-200 text-red-800 rounded-lg text-sm font-semibold transition-colors"
                >
                  Clear All Filters
                </button>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Match Count Display */}
      {(hasActiveFilters || matchTypeFilter !== 'all') && (
        <div className="mb-3 px-3 py-2 bg-blue-100 text-blue-800 rounded text-sm font-semibold">
          {showPending && showCompleted && (
            <>Showing {displayedPending} pending + {displayedMatches} completed of {totalPending + totalMatches} total matches</>
          )}
          {showPending && !showCompleted && (
            <>Showing {displayedPending} of {totalPending} pending matches</>
          )}
          {!showPending && showCompleted && (
            <>Showing {displayedMatches} of {totalMatches} completed matches</>
          )}
        </div>
      )}

      {/* ===== TODAY'S MATCHES SECTION (Always Visible, Prominent) ===== */}
      <section className="mb-8">
        <div className="bg-gradient-to-r from-blue-500 to-blue-600 rounded-lg shadow-lg p-6 mb-6">
          <h2 className="text-3xl font-bold text-white flex items-center gap-3 mb-4">
            <Calendar className="w-8 h-8" />
            ðŸ“… TODAY'S MATCHES ({todaysMatches.length})
          </h2>

          {todaysMatches.length === 0 ? (
            <div className="bg-white/10 backdrop-blur-sm border-2 border-white/30 rounded-lg p-8 text-center">
              <p className="text-white text-lg font-semibold">No matches scheduled for today</p>
              <p className="text-blue-100 text-sm mt-2">Check the pending matches below for upcoming games</p>
            </div>
          ) : (
            <div className="space-y-3">
              {/* Today's Pending Matches */}
              {todaysPendingMatches.map(match => {
                const team1 = teams.find(t => t.id === match.team1Id);
                const team2 = teams.find(t => t.id === match.team2Id);
                const team1Players = getPlayerNames(match.team1Players);
                const team2Players = getPlayerNames(match.team2Players);

                return (
                  <div
                    key={match.matchId}
                    className="bg-white/95 backdrop-blur-sm border-2 border-blue-300 rounded-lg p-4"
                  >
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        {/* Match Title */}
                        <div className="flex items-center gap-3 mb-2">
                          <TeamLogo team={team1} size="sm" showBorder={!!team1?.logo} />
                          <h4 className="font-bold text-gray-900">
                            {getTeamName(match.team1Id)}
                          </h4>
                          <span className="text-blue-600 font-semibold">vs</span>
                          <TeamLogo team={team2} size="sm" showBorder={!!team2?.logo} />
                          <h4 className="font-bold text-gray-900">
                            {getTeamName(match.team2Id)}
                          </h4>
                          <span className="px-2 py-1 bg-blue-200 text-blue-900 text-xs font-medium rounded">
                            Level {match.level}
                          </span>
                          <span className="px-2 py-1 bg-purple-200 text-purple-900 text-xs font-medium rounded">
                            {getDisplayMatchType(match, players)}
                          </span>
                          <span className="px-2 py-1 bg-yellow-200 text-yellow-900 text-xs font-bold rounded flex items-center gap-1 animate-pulse">
                            <Clock className="w-3 h-3" />
                            TODAY - Awaiting Results
                          </span>
                        </div>

                        {/* Players */}
                        <div className="grid grid-cols-2 gap-4 text-sm mb-2">
                          <div>
                            <div className="font-semibold text-gray-700 mb-1">
                              {getTeamName(match.team1Id)} Players:
                            </div>
                            {team1Players.length > 0 ? (
                              team1Players.map((player, idx) => (
                                <div key={idx} className="text-gray-600">
                                  â€¢ {player.name} ({player.gender}) {formatNTRP(player.rating)}
                                </div>
                              ))
                            ) : (
                              <div className="text-gray-500 italic">No players listed</div>
                            )}
                          </div>

                          <div>
                            <div className="font-semibold text-gray-700 mb-1">
                              {getTeamName(match.team2Id)} Players:
                            </div>
                            {team2Players.length > 0 ? (
                              team2Players.map((player, idx) => (
                                <div key={idx} className="text-gray-600">
                                  â€¢ {player.name} ({player.gender}) {formatNTRP(player.rating)}
                                </div>
                              ))
                            ) : (
                              <div className="text-gray-500 italic">No players listed</div>
                            )}
                          </div>
                        </div>

                        {/* Metadata */}
                        <div className="text-xs text-gray-500 italic mt-3 pt-2 border-t border-gray-300">
                          {match.matchId && (
                            <span className="font-mono font-semibold">Match ID: {match.matchId}</span>
                          )}
                        </div>
                      </div>

                      {/* Action Buttons */}
                      <div className="ml-4 flex flex-col gap-2">
                        {canEditPendingMatch(match) && (
                          <button
                            onClick={() => handleEditPendingMatch(match)}
                            className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors font-medium whitespace-nowrap"
                          >
                            <Edit2 className="w-4 h-4" />
                            Edit
                          </button>
                        )}
                        {canEnterResults(match) && (
                          <button
                            onClick={() => handleOpenResultsModal(match)}
                            className="flex items-center gap-2 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors font-medium whitespace-nowrap"
                          >
                            <Check className="w-4 h-4" />
                            Enter Results
                          </button>
                        )}
                        {userRole === 'director' && (
                          <button
                            onClick={() => handleDeletePendingMatch(match)}
                            className="flex items-center gap-2 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition-colors font-medium whitespace-nowrap"
                          >
                            <Trash2 className="w-4 h-4" />
                            Delete
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                );
              })}

              {/* Today's Completed Matches */}
              {todaysCompletedMatches.map(match => {
                // Safety check: Only render matches with status='completed' and valid scores
                if (match.status !== 'completed') {
                  console.error('âš ï¸ Skipping non-completed match in today completed section:', {
                    id: match.matchId,
                    status: match.status
                  });
                  return null;
                }
                if (!match.team1Sets && !match.team2Sets) {
                  console.error('âš ï¸ Skipping match with missing scores:', {
                    id: match.matchId,
                    status: match.status,
                    team1Sets: match.team1Sets,
                    team2Sets: match.team2Sets
                  });
                  return null;
                }

                const team1 = teams.find(t => t.id == match.team1Id);
                const team2 = teams.find(t => t.id == match.team2Id);

                return (
                  <div key={match.id} className="bg-white/95 backdrop-blur-sm border-2 border-green-300 rounded-lg p-4">
                    <div className="flex justify-between items-start">
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-1">
                          <span className="px-2 py-1 bg-green-600 text-white text-xs font-bold rounded">
                            âœ“ COMPLETED TODAY
                          </span>
                          {match.winner === 'team1' ? (
                            <>
                              <TeamLogo team={team1} size="sm" showBorder={!!team1?.logo} />
                              <span className="font-bold text-green-600">
                                {team1 ? team1.name : 'Team ' + match.team1Id}
                              </span>
                              <span className="text-sm">def.</span>
                              <TeamLogo team={team2} size="sm" showBorder={!!team2?.logo} />
                              <span className="font-semibold">
                                {team2 ? team2.name : 'Team ' + match.team2Id}
                              </span>
                            </>
                          ) : (
                            <>
                              <TeamLogo team={team2} size="sm" showBorder={!!team2?.logo} />
                              <span className="font-bold text-green-600">
                                {team2 ? team2.name : 'Team ' + match.team2Id}
                              </span>
                              <span className="text-sm">def.</span>
                              <TeamLogo team={team1} size="sm" showBorder={!!team1?.logo} />
                              <span className="font-semibold">
                                {team1 ? team1.name : 'Team ' + match.team1Id}
                              </span>
                            </>
                          )}
                          <span className="font-semibold text-blue-600">
                            {formatSetScores(match)}
                          </span>
                          <span className="px-2 py-1 bg-gray-200 text-gray-700 text-xs font-medium rounded">
                            Level {match.level}
                          </span>
                          <span className="px-2 py-1 bg-purple-200 text-purple-900 text-xs font-medium rounded">
                            {getDisplayMatchType(match, players)}
                          </span>
                        </div>
                        <div className="text-sm text-gray-600">
                          {formatDate(match.date)}
                          {match.notes && <span className="ml-2 italic">â€¢ {match.notes}</span>}
                        </div>

                        {/* Metadata */}
                        <div className="text-xs text-gray-500 italic mt-2 pt-2 border-t border-gray-200">
                          {match.matchId && (
                            <span className="font-mono font-semibold">Match ID: {match.matchId}</span>
                          )}
                        </div>
                      </div>
                      {isAuthenticated && canEditMatch(match) && (
                        <div className="flex gap-2">
                          <button
                            onClick={() => handleEditMatch(match)}
                            className="text-blue-600 hover:text-blue-800 p-1"
                          >
                            <Edit className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleDeleteMatch(match.id)}
                            className="text-red-600 hover:text-red-800 p-1"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
      </section>

      {/* ===== PENDING MATCHES SECTION (Collapsible) ===== */}
      {showPending && (
        <section className="mb-8">
          <div
            className="flex items-center gap-3 mb-4 cursor-pointer hover:bg-gray-100 p-3 rounded-lg transition-colors"
            onClick={() => setPendingExpanded(!pendingExpanded)}
            role="button"
            tabIndex={0}
            aria-expanded={pendingExpanded}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                setPendingExpanded(!pendingExpanded);
              }
            }}
          >
            <span className="text-2xl text-orange-600">
              {pendingExpanded ? 'â–¼' : 'â–¶'}
            </span>
            <Clock className="w-5 h-5 text-orange-700" />
            <h3 className="text-xl font-bold text-orange-700">
              PENDING MATCHES ({pendingMatchesExcludingToday.length})
            </h3>
            <span className="text-sm text-gray-500 italic">
              (Click to {pendingExpanded ? 'collapse' : 'expand'})
            </span>
          </div>

          {pendingExpanded && (
            <>
              {pendingMatchesExcludingToday.length === 0 ? (
                <p className="text-gray-500 text-center py-6 bg-gray-50 rounded border border-gray-200">
                  No pending matches
                </p>
              ) : (
                <div className="space-y-3">
                  {pendingMatchesExcludingToday.map(match => {
                const team1 = teams.find(t => t.id === match.team1Id);
                const team2 = teams.find(t => t.id === match.team2Id);
                const team1Players = getPlayerNames(match.team1Players);
                const team2Players = getPlayerNames(match.team2Players);

                // Check if match is overdue (1 day past the scheduled date)
                const isOverdue = match.scheduledDate && (() => {
                  // Parse date as LOCAL time, not UTC (avoid timezone issues)
                  const [year, month, day] = match.scheduledDate.split('-').map(Number);
                  const scheduledDate = new Date(year, month - 1, day); // Month is 0-indexed

                  // Create a date for 1 day after scheduled date (local time)
                  const oneDayAfterScheduled = new Date(year, month - 1, day + 1);

                  // Get today's date at midnight (local time)
                  const today = new Date();
                  today.setHours(0, 0, 0, 0);

                  return today >= oneDayAfterScheduled;
                })();

                return (
                  <div
                    key={match.matchId}
                    className={`border-2 rounded-lg p-4 transition-colors ${
                      isOverdue
                        ? 'bg-red-50 border-red-400 hover:bg-red-100'
                        : 'bg-orange-50 border-orange-300 hover:bg-orange-100'
                    }`}
                  >
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        {/* Match Title */}
                        <div className="flex items-center gap-3 mb-2">
                          <TeamLogo team={team1} size="sm" showBorder={!!team1?.logo} />
                          <h4 className="font-bold text-gray-900">
                            {getTeamName(match.team1Id)}
                          </h4>
                          <span className="text-blue-600 font-semibold">vs</span>
                          <TeamLogo team={team2} size="sm" showBorder={!!team2?.logo} />
                          <h4 className="font-bold text-gray-900">
                            {getTeamName(match.team2Id)}
                          </h4>
                          <span className="px-2 py-1 bg-orange-200 text-orange-900 text-xs font-medium rounded">
                            Level {match.level}
                          </span>
                          <span className="px-2 py-1 bg-purple-200 text-purple-900 text-xs font-medium rounded">
                            {getDisplayMatchType(match, players)}
                          </span>
                          <span className="px-2 py-1 bg-yellow-200 text-yellow-900 text-xs font-medium rounded flex items-center gap-1">
                            <Clock className="w-3 h-3" />
                            Awaiting Results
                          </span>
                          {isOverdue && (
                            <span className="px-2 py-1 bg-red-600 text-white text-xs font-bold rounded flex items-center gap-1 animate-pulse">
                              <AlertCircle className="w-3 h-3" />
                              Results Past Due
                            </span>
                          )}
                        </div>

                        {/* Players */}
                        <div className="grid grid-cols-2 gap-4 text-sm mb-2">
                          <div>
                            <div className="font-semibold text-gray-700 mb-1">
                              {getTeamName(match.team1Id)} Players:
                            </div>
                            {team1Players.length > 0 ? (
                              team1Players.map((player, idx) => (
                                <div key={idx} className="text-gray-600">
                                  â€¢ {player.name} ({player.gender}) {formatNTRP(player.rating)}
                                </div>
                              ))
                            ) : (
                              <div className="text-gray-500 italic">No players listed</div>
                            )}
                          </div>

                          <div>
                            <div className="font-semibold text-gray-700 mb-1">
                              {getTeamName(match.team2Id)} Players:
                            </div>
                            {team2Players.length > 0 ? (
                              team2Players.map((player, idx) => (
                                <div key={idx} className="text-gray-600">
                                  â€¢ {player.name} ({player.gender}) {formatNTRP(player.rating)}
                                </div>
                              ))
                            ) : (
                              <div className="text-gray-500 italic">No players listed</div>
                            )}
                          </div>
                        </div>

                        {/* Scheduled Date */}
                        {match.scheduledDate && (
                          <div className="flex items-center gap-1 text-sm text-gray-700 mb-2">
                            <Calendar className="w-4 h-4" />
                            <span>Scheduled: {formatDate(match.scheduledDate)}</span>
                          </div>
                        )}

                        {/* Metadata Footer - Match ID and Dates */}
                        <div className="text-xs text-gray-500 italic mt-3 pt-2 border-t border-gray-300">
                          {match.matchId && (
                            <span className="font-mono font-semibold">Match ID: {match.matchId}</span>
                          )}
                          {match.createdAt && (
                            <span className={match.matchId ? "ml-2" : ""}>
                              {match.matchId && "| "}Created: {formatDate(match.createdAt)}
                            </span>
                          )}
                        </div>
                        {match.notes && (
                          <div className="text-sm text-gray-600 mt-2">
                            <strong>Notes:</strong> {match.notes}
                          </div>
                        )}
                      </div>

                      {/* Action Buttons */}
                      <div className="ml-4 flex flex-col gap-2">
                        {/* Edit Button */}
                        {canEditPendingMatch(match) && (
                          <button
                            onClick={() => handleEditPendingMatch(match)}
                            className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors font-medium whitespace-nowrap"
                            title="Edit this pending match"
                          >
                            <Edit2 className="w-4 h-4" />
                            Edit
                          </button>
                        )}

                        {/* Enter Results Button */}
                        {canEnterResults(match) && (
                          <button
                            onClick={() => handleOpenResultsModal(match)}
                            className="flex items-center gap-2 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors font-medium whitespace-nowrap"
                          >
                            <Check className="w-4 h-4" />
                            Enter Results
                          </button>
                        )}

                        {/* Delete Button (Directors Only) */}
                        {userRole === 'director' && (
                          <button
                            onClick={() => handleDeletePendingMatch(match)}
                            className="flex items-center gap-2 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition-colors font-medium whitespace-nowrap"
                            title="Delete this pending match"
                          >
                            <Trash2 className="w-4 h-4" />
                            Delete
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </>
      )}
        </section>
      )}

      {/* ===== COMPLETED MATCHES SECTION (Collapsible) ===== */}
      {showCompleted && (
        <section>
          <div
            className="flex items-center gap-3 mb-4 cursor-pointer hover:bg-gray-100 p-3 rounded-lg transition-colors"
            onClick={() => setCompletedExpanded(!completedExpanded)}
            role="button"
            tabIndex={0}
            aria-expanded={completedExpanded}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                setCompletedExpanded(!completedExpanded);
              }
            }}
          >
            <span className="text-2xl text-green-600">
              {completedExpanded ? 'â–¼' : 'â–¶'}
            </span>
            <TrendingUp className="w-5 h-5 text-green-700" />
            <h3 className="text-xl font-bold text-green-700">
              COMPLETED MATCHES ({completedMatchesExcludingToday.length})
            </h3>
            <span className="text-sm text-gray-500 italic">
              (Click to {completedExpanded ? 'collapse' : 'expand'})
            </span>
          </div>

          {completedExpanded && (
            <>
              {matches.length === 0 ? (
                <p className="text-gray-500 text-center py-6 bg-gray-50 rounded border border-gray-200">
                  No completed matches yet
                </p>
              ) : completedMatchesExcludingToday.length === 0 ? (
                <p className="text-gray-500 text-center py-6 bg-gray-50 rounded border border-gray-200">
                  No matches found matching the selected filters
                </p>
              ) : (
                <div className="space-y-3">
                  {completedMatchesExcludingToday.slice(0, 20).map(match => {
            // Safety check: Only render matches with status='completed' and valid scores
            if (match.status !== 'completed') {
              console.error('âš ï¸ Skipping non-completed match in completed section:', {
                id: match.matchId,
                status: match.status
              });
              return null;
            }
            if (!match.team1Sets && !match.team2Sets) {
              console.error('âš ï¸ Skipping match with missing scores:', {
                id: match.matchId,
                status: match.status,
                team1Sets: match.team1Sets,
                team2Sets: match.team2Sets
              });
              return null;
            }

            const team1 = teams.find(t => t.id == match.team1Id);
            const team2 = teams.find(t => t.id == match.team2Id);

            return (
              <div key={match.id} className="border rounded p-3 hover:bg-gray-50">
                <div className="flex justify-between items-start">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      {match.winner === 'team1' ? (
                        <>
                          <TeamLogo team={team1} size="sm" showBorder={!!team1?.logo} />
                          <span className="font-bold text-green-600">
                            {team1 ? team1.name : 'Team ' + match.team1Id}
                          </span>
                          <span className="text-sm">def.</span>
                          <TeamLogo team={team2} size="sm" showBorder={!!team2?.logo} />
                          <span className="font-semibold">
                            {team2 ? team2.name : 'Team ' + match.team2Id}
                          </span>
                        </>
                      ) : (
                        <>
                          <TeamLogo team={team2} size="sm" showBorder={!!team2?.logo} />
                          <span className="font-bold text-green-600">
                            {team2 ? team2.name : 'Team ' + match.team2Id}
                          </span>
                          <span className="text-sm">def.</span>
                          <TeamLogo team={team1} size="sm" showBorder={!!team1?.logo} />
                          <span className="font-semibold">
                            {team1 ? team1.name : 'Team ' + match.team1Id}
                          </span>
                        </>
                      )}
                      <span className="font-semibold text-blue-600">
                        {formatSetScores(match)}
                      </span>
                      <span className="px-2 py-1 bg-gray-200 text-gray-700 text-xs font-medium rounded">
                        Level {match.level}
                      </span>
                      <span className="px-2 py-1 bg-purple-200 text-purple-900 text-xs font-medium rounded">
                        {getDisplayMatchType(match, players)}
                      </span>
                    </div>
                    <div className="text-sm text-gray-600">
                      {formatDate(match.date)}
                      {match.notes && <span className="ml-2 italic">â€¢ {match.notes}</span>}
                    </div>

                    {/* Display Players */}
                    {((match.team1Players && match.team1Players.length > 0) || 
                      (match.team2Players && match.team2Players.length > 0)) && (
                      <div className="mt-2 text-xs">
                        {match.team1Players && match.team1Players.length > 0 && (
                          <div className="text-gray-500">
                            <span className="font-semibold">{team1 ? team1.name : 'Team 1'} Players:</span>{' '}
                            {match.team1Players.map((playerId, index) => (
                              <span key={playerId}>
                                {getPlayerName(playerId)}
                                {index < match.team1Players.length - 1 ? ', ' : ''}
                              </span>
                            ))}
                          </div>
                        )}
                        {match.team2Players && match.team2Players.length > 0 && (
                          <div className="text-gray-500">
                            <span className="font-semibold">{team2 ? team2.name : 'Team 2'} Players:</span>{' '}
                            {match.team2Players.map((playerId, index) => (
                              <span key={playerId}>
                                {getPlayerName(playerId)}
                                {index < match.team2Players.length - 1 ? ', ' : ''}
                              </span>
                            ))}
                          </div>
                        )}
                      </div>
                    )}

                    {/* Metadata Footer - Match ID and Dates */}
                    <div className="text-xs text-gray-500 italic mt-3 pt-2 border-t border-gray-200">
                      {match.matchId && (
                        <span className="font-mono font-semibold">Match ID: {match.matchId}</span>
                      )}
                      {match.timestamp && (
                        <span className={match.matchId ? "ml-2" : ""}>
                          {match.matchId && "| "}Entered: {formatDate(match.timestamp)}
                        </span>
                      )}
                      {match.originChallengeId && (
                        <span className="ml-2">| From Challenge: {match.originChallengeId}</span>
                      )}
                    </div>
                  </div>
                  {isAuthenticated && canEditMatch(match) && (
                    <div className="flex gap-2">
                      <button
                        onClick={() => handleEditMatch(match)}
                        className="text-blue-600 hover:text-blue-800 p-1"
                        title="Edit match"
                      >
                        <Edit className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => handleDeleteMatch(match.id)}
                        className="text-red-600 hover:text-red-800 p-1"
                        title="Delete match"
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  )}
                </div>
              </div>
            );
          })}
            </div>
          )}
        </>
      )}
        </section>
      )}

      {/* Edit Pending Match Modal */}
      {showEditPendingModal && editingPendingMatch && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
            <div className="px-6 py-4 border-b border-gray-200">
              <h3 className="text-xl font-bold text-gray-900">Edit Pending Match</h3>
              <div className="flex items-center gap-3 text-xs text-gray-600 mt-1 flex-wrap">
                {editingPendingMatch.matchId && (
                  <div className="font-mono bg-blue-100 px-2 py-1 rounded">
                    <span className="font-semibold">Match ID:</span> {editingPendingMatch.matchId}
                  </div>
                )}
                {editingPendingMatch.challengeId && editingPendingMatch.origin !== 'direct' && (
                  <div className="font-mono bg-orange-100 px-2 py-1 rounded">
                    <span className="font-semibold">Origin Challenge ID:</span> {editingPendingMatch.challengeId}
                  </div>
                )}
              </div>
              <p className="text-sm text-gray-600 mt-1">
                {getTeamName(editingPendingMatch.team1Id)} vs {getTeamName(editingPendingMatch.team2Id)}
              </p>
              <div className="flex items-center gap-3 text-xs text-gray-500 mt-1">
                {editingPendingMatch.createdAt && (
                  <div className="flex items-center gap-1">
                    <Clock className="w-3 h-3" />
                    <span>Created: {formatDate(editingPendingMatch.createdAt)}</span>
                  </div>
                )}
              </div>
            </div>

            <div className="px-6 py-4 space-y-4">
              {/* Match Date */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Match Date *
                </label>
                <input
                  type="date"
                  value={editPendingFormData.acceptedDate}
                  onChange={(e) => setEditPendingFormData({...editPendingFormData, acceptedDate: e.target.value})}
                  className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>

              {/* Level */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Match Level
                </label>
                <select
                  value={editPendingFormData.acceptedLevel}
                  onChange={(e) => setEditPendingFormData({...editPendingFormData, acceptedLevel: e.target.value})}
                  className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  {['6.0', '6.5', '7.0', '7.5', '8.0', '8.5', '9.0', '9.5', '10.0'].map(level => (
                    <option key={level} value={level}>{level}</option>
                  ))}
                </select>
              </div>

              {/* Two-column player selection */}
              <div className="grid grid-cols-2 gap-4">
                {/* Team 1 Players */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    {getTeamName(editingPendingMatch.team1Id)} Players (Select 2) *
                  </label>
                  <div className="border border-gray-300 rounded p-4 max-h-48 overflow-y-auto space-y-2">
                    {getTeamRoster(editingPendingMatch.team1Id).map(player => (
                      <label key={player.id} className="flex items-center gap-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                        <input
                          type="checkbox"
                          checked={editPendingFormData.team1Players.includes(player.id)}
                          onChange={(e) => {
                            if (e.target.checked) {
                              if (editPendingFormData.team1Players.length >= 2) {
                                alert('âš ï¸ You can only select 2 players for doubles.');
                                return;
                              }
                              setEditPendingFormData({
                                ...editPendingFormData,
                                team1Players: [...editPendingFormData.team1Players, player.id]
                              });
                            } else {
                              setEditPendingFormData({
                                ...editPendingFormData,
                                team1Players: editPendingFormData.team1Players.filter(id => id !== player.id)
                              });
                            }
                          }}
                          className="rounded"
                        />
                        <span className="text-sm">
                          {player.firstName} {player.lastName}
                          <span className="text-gray-500 ml-2">
                            ({player.gender}) {player.ntrpRating} NTRP
                          </span>
                        </span>
                      </label>
                    ))}
                  </div>
                  <div className="mt-2 space-y-1">
                    <p className="text-sm text-gray-600">
                      Selected: {editPendingFormData.team1Players.length} / 2 players
                    </p>
                    {editPendingFormData.team1Players.length === 2 && (
                      <div className={`text-sm font-medium ${
                        validateCombinedNTRP(editPendingFormData.team1Players, editPendingFormData.acceptedLevel)
                          ? 'text-green-600'
                          : 'text-red-600'
                      }`}>
                        Combined NTRP: {calculateCombinedNTRP(editPendingFormData.team1Players).toFixed(1)}
                        {!validateCombinedNTRP(editPendingFormData.team1Players, editPendingFormData.acceptedLevel) && (
                          <span className="block text-xs mt-0.5">
                            âš ï¸ Exceeds match level ({editPendingFormData.acceptedLevel})
                          </span>
                        )}
                      </div>
                    )}
                  </div>
                </div>

                {/* Team 2 Players */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    {getTeamName(editingPendingMatch.team2Id)} Players (Select 2) *
                  </label>
                  <div className="border border-gray-300 rounded p-4 max-h-48 overflow-y-auto space-y-2">
                    {getTeamRoster(editingPendingMatch.team2Id).map(player => (
                      <label key={player.id} className="flex items-center gap-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                        <input
                          type="checkbox"
                          checked={editPendingFormData.team2Players.includes(player.id)}
                          onChange={(e) => {
                            if (e.target.checked) {
                              if (editPendingFormData.team2Players.length >= 2) {
                                alert('âš ï¸ You can only select 2 players for doubles.');
                                return;
                              }
                              setEditPendingFormData({
                                ...editPendingFormData,
                                team2Players: [...editPendingFormData.team2Players, player.id]
                              });
                            } else {
                              setEditPendingFormData({
                                ...editPendingFormData,
                                team2Players: editPendingFormData.team2Players.filter(id => id !== player.id)
                              });
                            }
                          }}
                          className="rounded"
                        />
                        <span className="text-sm">
                          {player.firstName} {player.lastName}
                          <span className="text-gray-500 ml-2">
                            ({player.gender}) {player.ntrpRating} NTRP
                          </span>
                        </span>
                      </label>
                    ))}
                  </div>
                  <div className="mt-2 space-y-1">
                    <p className="text-sm text-gray-600">
                      Selected: {editPendingFormData.team2Players.length} / 2 players
                    </p>
                    {editPendingFormData.team2Players.length === 2 && (
                      <div className={`text-sm font-medium ${
                        validateCombinedNTRP(editPendingFormData.team2Players, editPendingFormData.acceptedLevel)
                          ? 'text-green-600'
                          : 'text-red-600'
                      }`}>
                        Combined NTRP: {calculateCombinedNTRP(editPendingFormData.team2Players).toFixed(1)}
                        {!validateCombinedNTRP(editPendingFormData.team2Players, editPendingFormData.acceptedLevel) && (
                          <span className="block text-xs mt-0.5">
                            âš ï¸ Exceeds match level ({editPendingFormData.acceptedLevel})
                          </span>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>

            <div className="px-6 py-4 border-t border-gray-200 flex gap-3">
              <button
                onClick={handleConfirmEditPending}
                className="flex-1 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors font-medium"
              >
                Save Changes
              </button>
              <button
                onClick={() => {
                  setShowEditPendingModal(false);
                  setEditingPendingMatch(null);
                }}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 transition-colors"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Enter Results Modal - Shared Component */}
      <MatchResultsModal
        isOpen={showResultsModal}
        match={selectedMatch ? {
          team1Id: selectedMatch.team1Id,
          team2Id: selectedMatch.team2Id,
          matchId: selectedMatch.matchId,
          acceptedLevel: selectedMatch.level,
          proposedLevel: selectedMatch.level,
          acceptedDate: selectedMatch.scheduledDate,
          challengeId: selectedMatch.challengeId
        } : null}
        teams={teams}
        players={players}
        matches={matches}
        onSubmit={handleSubmitResults}
        onClose={handleCloseResultsModal}
        addLog={addLog}
        ACTION_TYPES={ACTION_TYPES}
      />
    </div>
  );
};

export default MatchHistory;